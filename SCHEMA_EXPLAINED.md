# Database Schema Design - Complete Beginner's Guide

## üìñ Table of Contents

1. [The Big Picture](#the-big-picture)
2. [Understanding the Problem](#understanding-the-problem)
3. [The Solution: Our Schema Design](#the-solution-our-schema-design)
4. [Task Collection Explained](#task-collection-explained)
5. [Board Collection Explained](#board-collection-explained)
6. [How They Work Together](#how-they-work-together)
7. [Database Indexes Explained](#database-indexes-explained)
8. [Complete User Journeys](#complete-user-journeys)
9. [Why This Design?](#why-this-design)
10. [Alternative Approaches (and why we didn't use them)](#alternative-approaches)

---

## The Big Picture

### What Are We Building?

A Kanban board app like Trello or Jira where:

- Users can create **boards**
- Each board has **categories** (columns like "To Do", "In Progress", "Done")
- Each category contains **tasks** (cards)
- Users can drag tasks between categories
- Users can click a task to see full details

### What's in the Database?

We store data in **2 collections** (think of them as 2 Excel spreadsheets):

1. **Tasks Collection** - Every single task from all boards
2. **Boards Collection** - Every board with its categories

---

## Understanding the Problem

### The Challenge

Imagine you have:

- **100 boards**
- Each board has **5 categories**
- Each category has **20 tasks**
- Total: **10,000 tasks**

Now answer these questions FAST:

1. Show me all tasks in "My Project Board"
2. Show me task "T-1234" with its board and category name
3. Move task "T-1234" from "To Do" to "In Progress"
4. What's the order of tasks in the "Done" category?

**The problem:** How do we organize data so we can answer these questions with **minimal database queries**?

---

## The Solution: Our Schema Design

### Core Principle: Smart Redundancy

Instead of storing data in ONE place, we store it in TWO places:

1. **Tasks know where they belong** (which board, which category)
2. **Boards know what tasks they contain** (and in what order)

This is **intentional duplication** that makes everything faster.

---

## Task Collection Explained

### What Does a Task Look Like?

```javascript
{
  // Unique identifiers
  _id: "507f1f77bcf86cd799439011",        // MongoDB's auto-generated ID
  taskId: "T-100",                        // Human-readable ID for URLs

  // Basic info
  name: "Setup project infrastructure",
  description: "Set up CI/CD pipeline...",

  // ‚≠ê LOCATION: Where does this task belong?
  boardId: "68e5647b50b6da7d17a9c32b",    // Which board owns me?
  categoryId: "todo",                      // Which category am I in?

  // ‚≠ê CACHED DATA: Pre-stored for speed
  boardName: "My First Board",             // Don't need to look up board
  categoryName: "To Do",                   // Don't need to look up category

  // Task details
  priority: "high",
  status: "todo",
  assignee: "68e6c5706c2f8a863fb414ec",   // User ID
  dueDate: "2024-01-15",
  tags: ["DCB", "TECH TASK"],
  timeEstimate: "4h",
  size: "S",
  jiraTicket: "https://jira.com/browse/GO-123",

  // Metadata
  createdBy: "68e6c5706c2f8a863fb414ec",
  createdAt: "2024-01-10T10:00:00Z",
  updatedAt: "2024-01-10T10:00:00Z"
}
```

### Breaking Down Each Field

#### 1. **`_id`** - MongoDB's Internal ID

```javascript
_id: "507f1f77bcf86cd799439011";
```

- Auto-generated by MongoDB
- Guaranteed to be unique across ALL tasks
- Used internally for lookups and references
- Never changes

#### 2. **`taskId`** - Human-Friendly ID

```javascript
taskId: "T-100";
```

- Used in URLs: `/task/T-100`
- Displayed to users: "Task T-100"
- Generated from board's `taskCounter`
- Must be unique across ALL tasks

#### 3. **`boardId`** - Which Board Owns This Task?

```javascript
boardId: "68e5647b50b6da7d17a9c32b";
```

**Why it matters:**

```javascript
// To show "My First Board", just query:
const allTasksInBoard = await Task.find({
  boardId: "68e5647b50b6da7d17a9c32b",
});

// ONE query gets ALL tasks for the board!
// No matter if there are 10 tasks or 10,000 tasks
```

**Without `boardId`:**

```javascript
// You'd have to:
// 1. Get the board
// 2. Loop through all categories
// 3. For each category, loop through all taskIds
// 4. Fetch each task one by one
// Result: HUNDREDS of database queries!
```

#### 4. **`categoryId`** - Which Category Am I In?

```javascript
categoryId: "todo";
```

**Why it matters:**

```javascript
// To show only "To Do" tasks:
const todoTasks = await Task.find({
  boardId: "68e5647b50b6da7d17a9c32b",
  categoryId: "todo",
});

// ONE query, super fast with the right index!
```

#### 5. **`boardName` & `categoryName`** - Cached Data

```javascript
boardName: "My First Board",
categoryName: "To Do"
```

**Why cache these?**

**Scenario: User clicks on task T-100**

Route: `/task/T-100`

Page needs to display:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ My First Board > To Do > T-100      ‚îÇ  ‚Üê Need these names!
‚îÇ                                     ‚îÇ
‚îÇ Task Name: Setup project...         ‚îÇ
‚îÇ Description: ...                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**With cached names:**

```javascript
// ONE query:
const task = await Task.findOne({ taskId: "T-100" });

// Already have:
// - task.boardName = "My First Board"
// - task.categoryName = "To Do"
// Done! Show the page!
```

**Without cached names:**

```javascript
// Step 1: Get task
const task = await Task.findOne({ taskId: "T-100" });

// Step 2: Get board to find board name
const board = await Board.findById(task.boardId);

// Step 3: Find category in board to get category name
const category = board.categories.find((c) => c.id === task.categoryId);

// Now we have all the data (3 queries total)
```

**Trade-off:**

- ‚úÖ Faster: 1 query instead of 3
- ‚ùå Must update if board/category is renamed (rare!)

---

## Board Collection Explained

### What Does a Board Look Like?

```javascript
{
  // Unique identifiers
  _id: "68e5647b50b6da7d17a9c32b",
  name: "My First Board",

  // Access control
  owner: "68e6c5706c2f8a863fb414ec",      // Who created this board
  members: [                               // Who can access it
    "68e6c5706c2f8a863fb414ec",
    "68e6c6836c2f8a863fb414ef"
  ],

  // Task ID generator
  taskCounter: 5,                          // Next task will be T-6

  // ‚≠ê CATEGORIES: The columns on the board
  categories: [
    {
      id: "unassigned",                    // Unique ID (slug)
      name: "Unassigned",                  // Display name
      taskIds: [],                         // ‚≠ê Array of task IDs IN ORDER
      order: 0,                            // Which column comes first?
      color: "#808080"                     // For the UI
    },
    {
      id: "todo",
      name: "To Do",
      taskIds: [                           // ‚≠ê Order matters here!
        "task_001",                        // First task
        "task_003",                        // Second task
        "task_004"                         // Third task
      ],
      order: 1,
      color: "#3B82F6"
    },
    {
      id: "in-progress",
      name: "In Progress",
      taskIds: ["task_002", "task_005"],
      order: 2,
      color: "#F59E0B"
    },
    {
      id: "done",
      name: "Done",
      taskIds: [],
      order: 3,
      color: "#10B981"
    }
  ],

  // Metadata
  createdAt: "2024-01-10T10:00:00Z",
  updatedAt: "2024-01-15T14:30:00Z"
}
```

### Breaking Down Each Field

#### 1. **`taskCounter`** - Auto-incrementing Number

```javascript
taskCounter: 5;
```

**How it works:**

```javascript
// User creates a new task:
// 1. Get current counter: 5
// 2. Generate ID: "T-6"
// 3. Increment counter: 5 ‚Üí 6
// 4. Next task will be "T-7"

// This ensures every task has a unique, sequential ID
```

#### 2. **`categories`** - The Columns

```javascript
categories: [
  {
    id: "todo",
    name: "To Do",
    taskIds: ["task_001", "task_003", "task_004"],
    order: 1,
    color: "#3B82F6",
  },
];
```

**Field breakdown:**

- **`id`**: Used in code (`"todo"`, `"in-progress"`)

  - Never shown to users
  - URL-friendly (no spaces)
  - Stays the same even if `name` changes

- **`name`**: Shown to users (`"To Do"`, `"In Progress"`)

  - Can be changed by users
  - Can have spaces, emojis, etc.

- **`taskIds`**: THE ORDER OF TASKS IN THIS CATEGORY

  ```javascript
  // User sees tasks in this order:
  taskIds: ["task_001", "task_003", "task_004"];
  //        First       Second      Third
  ```

- **`order`**: Which column comes first on the board

  ```javascript
  // Columns are displayed:
  order: 0 ‚Üí "Unassigned"
  order: 1 ‚Üí "To Do"
  order: 2 ‚Üí "In Progress"
  order: 3 ‚Üí "Done"
  ```

- **`color`**: Background color for the column header

---

## How They Work Together

### Visual Representation

```
DATABASE
‚îÇ
‚îú‚îÄ BOARDS Collection
‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ Board: "My First Board"
‚îÇ     ‚îÇ
‚îÇ     ‚îú‚îÄ categories: [
‚îÇ     ‚îÇ   {
‚îÇ     ‚îÇ     id: "todo",
‚îÇ     ‚îÇ     name: "To Do",
‚îÇ     ‚îÇ     taskIds: ["task_001", "task_003"]  ‚Üê References tasks
‚îÇ     ‚îÇ   },
‚îÇ     ‚îÇ   {
‚îÇ     ‚îÇ     id: "in-progress",
‚îÇ     ‚îÇ     name: "In Progress",
‚îÇ     ‚îÇ     taskIds: ["task_002"]
‚îÇ     ‚îÇ   }
‚îÇ     ‚îÇ ]
‚îÇ     ‚îÇ
‚îÇ     ‚îî‚îÄ taskCounter: 5
‚îÇ
‚îî‚îÄ TASKS Collection
   ‚îÇ
   ‚îú‚îÄ Task 001
   ‚îÇ  ‚îú‚îÄ taskId: "T-1"
   ‚îÇ  ‚îú‚îÄ name: "Setup project"
   ‚îÇ  ‚îú‚îÄ boardId: "board_123"          ‚Üê Points back to board
   ‚îÇ  ‚îú‚îÄ categoryId: "todo"            ‚Üê Points to category
   ‚îÇ  ‚îú‚îÄ boardName: "My First Board"   ‚Üê Cached
   ‚îÇ  ‚îî‚îÄ categoryName: "To Do"         ‚Üê Cached
   ‚îÇ
   ‚îú‚îÄ Task 002
   ‚îÇ  ‚îú‚îÄ taskId: "T-2"
   ‚îÇ  ‚îú‚îÄ name: "Design UI"
   ‚îÇ  ‚îú‚îÄ boardId: "board_123"
   ‚îÇ  ‚îú‚îÄ categoryId: "in-progress"
   ‚îÇ  ‚îú‚îÄ boardName: "My First Board"
   ‚îÇ  ‚îî‚îÄ categoryName: "In Progress"
   ‚îÇ
   ‚îî‚îÄ Task 003
      ‚îú‚îÄ taskId: "T-3"
      ‚îú‚îÄ name: "Write tests"
      ‚îú‚îÄ boardId: "board_123"
      ‚îú‚îÄ categoryId: "todo"
      ‚îú‚îÄ boardName: "My First Board"
      ‚îî‚îÄ categoryName: "To Do"
```

### The Two-Way Relationship

**Tasks ‚Üí Board** (Tasks know their parent)

```javascript
// Task 001 says: "I belong to board_123 in category 'todo'"
{
  _id: "task_001",
  boardId: "board_123",
  categoryId: "todo"
}
```

**Board ‚Üí Tasks** (Board knows its children)

```javascript
// Board says: "My 'todo' category contains task_001 and task_003"
{
  _id: "board_123",
  categories: [
    {
      id: "todo",
      taskIds: ["task_001", "task_003"]
    }
  ]
}
```

### Why Both Directions?

**Use Case 1: Show the board**

```javascript
// Need ALL tasks? Use Tasks ‚Üí Board direction:
const tasks = await Task.find({ boardId: "board_123" });
// Fast! One query!
```

**Use Case 2: Show tasks in order**

```javascript
// Need order? Use Board ‚Üí Tasks direction:
const board = await Board.findById("board_123");
const todoCategory = board.categories.find((c) => c.id === "todo");
const orderedTaskIds = todoCategory.taskIds;
// ["task_001", "task_003", "task_004"]

// Now fetch tasks in this order
const tasks = await Task.find({ _id: { $in: orderedTaskIds } });
// Sort by the order in taskIds array
```

---

## Database Indexes Explained

### What's an Index?

Think of a **book index**:

**Book without index:**

> "Find the word 'database' in this 500-page book"
>
> You: _Reads every page from start to finish_
>
> Time: 30 minutes

**Book with index:**

> "Find the word 'database' in this 500-page book"
>
> You: _Looks at index in back: "database - page 156"_
>
> You: _Turns to page 156_
>
> Time: 10 seconds

**Database indexes work the same way!**

### Our Indexes

#### Index 1: `{ boardId: 1 }`

**What it does:**
Creates a sorted list of all tasks by boardId

```
Index Table:
boardId         ‚Üí task location in database
---------------------------------------------
board_123       ‚Üí [task_001, task_003, task_004]
board_456       ‚Üí [task_010, task_011]
board_789       ‚Üí [task_020, task_021, task_022]
```

**Query example:**

```javascript
await Task.find({ boardId: "board_123" });
```

**Without index:**

- Database reads ALL 10,000 tasks
- Checks each one: "Is your boardId = board_123?"
- Time: 2 seconds

**With index:**

- Database looks at index
- Jumps directly to board_123 entries
- Returns only matching tasks
- Time: 5 milliseconds

---

#### Index 2: `{ taskId: 1 }, { unique: true }`

**What it does:**

1. Creates sorted list of all taskIds
2. Ensures no duplicates (unique constraint)

```
Index Table:
taskId    ‚Üí task location
--------------------------
T-1       ‚Üí task_001
T-2       ‚Üí task_002
T-3       ‚Üí task_003
T-100     ‚Üí task_100
```

**Query example:**

```javascript
await Task.findOne({ taskId: "T-100" });
```

**Speed:** Instant lookup (like a dictionary)

**Unique constraint:**

```javascript
// Try to create two tasks with same taskId:
await Task.create({ taskId: "T-1", ... });  // ‚úÖ Success
await Task.create({ taskId: "T-1", ... });  // ‚ùå Error: duplicate key

// Database prevents this automatically!
```

---

#### Index 3: `{ boardId: 1, categoryId: 1 }` (Compound)

**What it does:**
Creates a two-level sorted list

```
Index Table (two columns):
boardId      categoryId       ‚Üí tasks
-------------------------------------------
board_123    done            ‚Üí [task_005, task_008]
board_123    in-progress     ‚Üí [task_002, task_007]
board_123    todo            ‚Üí [task_001, task_003, task_004]
board_456    todo            ‚Üí [task_010, task_011]
```

**Query example:**

```javascript
await Task.find({
  boardId: "board_123",
  categoryId: "todo",
});
```

**How it works:**

1. Look up `board_123` (first column)
2. Within board_123, look up `todo` (second column)
3. Return matching tasks

**Bonus:** Can also be used for queries with JUST `boardId`:

```javascript
await Task.find({ boardId: "board_123" });
// Index still helps! Uses first column only.
```

---

## Complete User Journeys

### Journey 1: Loading a Board Page

**User action:** Opens `/boards/board_123`

**What needs to happen:**

1. Show board name
2. Show all categories in order
3. Show all tasks in each category in order

**Database queries:**

```javascript
// Step 1: Get board info
const board = await Board.findById("board_123");
// Returns:
// - name: "My First Board"
// - categories: [...]
// - taskCounter: 5

// Step 2: Get ALL tasks for this board
const tasks = await Task.find({ boardId: "board_123" });
// Index { boardId: 1 } makes this instant!
// Returns: [task_001, task_002, task_003, task_004, task_005]

// Step 3: Group tasks by category (in code, not database)
const tasksByCategory = {};
tasks.forEach((task) => {
  if (!tasksByCategory[task.categoryId]) {
    tasksByCategory[task.categoryId] = [];
  }
  tasksByCategory[task.categoryId].push(task);
});

// Result:
// tasksByCategory = {
//   "todo": [task_001, task_003, task_004],
//   "in-progress": [task_002, task_005]
// }

// Step 4: Sort tasks in each category by taskIds order
board.categories.forEach((category) => {
  const tasks = tasksByCategory[category.id] || [];
  const orderedTasks = category.taskIds.map((id) =>
    tasks.find((t) => t._id === id)
  );
  tasksByCategory[category.id] = orderedTasks;
});

// Step 5: Send to frontend
res.json({
  board: board,
  tasksByCategory: tasksByCategory,
});
```

**Total database queries: 2**
**Time: ~10 milliseconds**

---

### Journey 2: Viewing Task Details

**User action:** Clicks on task "T-100"

**Route:** `/task/T-100`

**What needs to show:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ My First Board > To Do > T-100        ‚îÇ ‚Üê Breadcrumb
‚îÇ                                        ‚îÇ
‚îÇ Task: Setup project infrastructure     ‚îÇ
‚îÇ Description: Set up CI/CD pipeline...  ‚îÇ
‚îÇ Priority: High                         ‚îÇ
‚îÇ Due Date: Jan 15, 2024                ‚îÇ
‚îÇ Tags: [DCB] [TECH TASK]               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Database queries:**

```javascript
// ONE query:
const task = await Task.findOne({ taskId: "T-100" });
// Index { taskId: 1 } makes this instant!

// Task already contains:
// - boardName: "My First Board"     ‚Üê For breadcrumb!
// - categoryName: "To Do"           ‚Üê For breadcrumb!
// - name, description, priority, etc.

// Done! Send to frontend:
res.json({ task });
```

**Total database queries: 1**
**Time: ~5 milliseconds**

---

### Journey 3: Creating a New Task

**User action:** Clicks "Create Task" in "To Do" category

**Form data:**

```javascript
{
  name: "Write documentation",
  description: "Create README and API docs",
  boardId: "board_123",
  categoryId: "todo",
  priority: "medium",
  size: "M",
  tags: ["DOCS"]
}
```

**Database operations:**

```javascript
// Step 1: Get board to generate task ID
const board = await Board.findById("board_123");
// board.taskCounter = 5

// Step 2: Create new task
const newTaskId = `T-${board.taskCounter + 1}`; // "T-6"

const task = await Task.create({
  taskId: newTaskId,
  name: "Write documentation",
  description: "Create README and API docs",
  boardId: "board_123",
  categoryId: "todo",
  boardName: board.name, // Cache: "My First Board"
  categoryName: "To Do", // Cache: "To Do"
  priority: "medium",
  size: "M",
  tags: ["DOCS"],
  createdAt: new Date(),
  updatedAt: new Date(),
});
// New task created with _id: "task_006"

// Step 3: Update board
await Board.updateOne(
  { _id: "board_123", "categories.id": "todo" },
  {
    $inc: { taskCounter: 1 }, // 5 ‚Üí 6
    $push: { "categories.$.taskIds": "task_006" }, // Add to end
  }
);

// Board's "todo" category now:
// taskIds: ["task_001", "task_003", "task_004", "task_006"]
```

**Total database queries: 3**

1. Read board
2. Create task
3. Update board

**Time: ~15 milliseconds**

---

### Journey 4: Dragging Task Between Categories

**User action:** Drags task_001 from "To Do" to "In Progress"

**Before:**

```
To Do:         [task_001, task_003, task_004]
In Progress:   [task_002, task_005]
```

**After:**

```
To Do:         [task_003, task_004]
In Progress:   [task_002, task_005, task_001]
```

**Database operations (with transaction):**

```javascript
const session = await mongoose.startSession();
session.startTransaction();

try {
  // Operation 1: Update task's categoryId
  await Task.updateOne(
    { _id: "task_001" },
    {
      categoryId: "in-progress",
      categoryName: "In Progress", // Update cached name!
    },
    { session }
  );

  // Operation 2: Remove from old category
  await Board.updateOne(
    { _id: "board_123", "categories.id": "todo" },
    {
      $pull: { "categories.$.taskIds": "task_001" },
    },
    { session }
  );
  // "To Do" taskIds: ["task_001", "task_003", "task_004"]
  //                   ‚Üì Remove task_001
  // "To Do" taskIds: ["task_003", "task_004"]

  // Operation 3: Add to new category
  await Board.updateOne(
    { _id: "board_123", "categories.id": "in-progress" },
    {
      $push: { "categories.$.taskIds": "task_001" },
    },
    { session }
  );
  // "In Progress" taskIds: ["task_002", "task_005"]
  //                         ‚Üì Add task_001
  // "In Progress" taskIds: ["task_002", "task_005", "task_001"]

  // All operations succeeded!
  await session.commitTransaction();
} catch (error) {
  // Something went wrong! Undo everything!
  await session.abortTransaction();
  throw error;
} finally {
  session.endSession();
}
```

**Why use a transaction?**

Imagine if Operation 2 succeeds but Operation 3 fails:

- Task_001 removed from "To Do" ‚úÖ
- Task_001 NOT added to "In Progress" ‚ùå
- Result: Task is LOST! üò±

**With transaction:**

- All 3 operations succeed together, OR
- All 3 operations fail together
- No in-between state
- Data stays consistent

**Total database queries: 3 (in transaction)**
**Time: ~20 milliseconds**

---

### Journey 5: Reordering Tasks in Same Category

**User action:** Drags task_003 above task_001 in "To Do"

**Before:**

```
To Do: [task_001, task_003, task_004]
        First     Second    Third
```

**After:**

```
To Do: [task_003, task_001, task_004]
        First     Second    Third
```

**Database operations:**

```javascript
// Step 1: Remove task_003 from array
await Board.updateOne(
  { _id: "board_123", "categories.id": "todo" },
  {
    $pull: { "categories.$.taskIds": "task_003" },
  }
);
// Result: ["task_001", "task_004"]

// Step 2: Insert task_003 at position 0 (first)
await Board.updateOne(
  { _id: "board_123", "categories.id": "todo" },
  {
    $push: {
      "categories.$.taskIds": {
        $each: ["task_003"], // Insert this
        $position: 0, // At this position
      },
    },
  }
);
// Result: ["task_003", "task_001", "task_004"]

// NOTE: Task document itself doesn't change!
// Only the order in board.categories[].taskIds changes.
```

**Total database queries: 2**
**Time: ~10 milliseconds**

---

## Why This Design?

### Design Goal: Optimize for Reads

**Statistics from real apps:**

- Users **view** boards: 1000 times/day
- Users **create** tasks: 10 times/day
- Users **move** tasks: 50 times/day
- Users **rename** categories: 1 time/month

**Conclusion:** Reading happens WAY more than writing!

**Our design:**

- ‚úÖ Super fast reads (1-2 queries)
- ‚úÖ Acceptable write speed (2-3 queries)
- ‚úÖ Rare operations (rename category) are slower, but who cares?

---

### Key Design Decisions

#### Decision 1: Store boardId on tasks

**Why:**

```javascript
// Load entire board:
const tasks = await Task.find({ boardId: "board_123" });
// ONE query! No matter how many tasks!
```

**Alternative (bad):**

```javascript
// Get board
// Get each category
// Get each taskId
// Fetch each task
// Result: HUNDREDS of queries
```

---

#### Decision 2: Cache boardName and categoryName on tasks

**Why:**

```javascript
// Show task detail page:
const task = await Task.findOne({ taskId: "T-100" });
// Already has: task.boardName, task.categoryName
// ONE query! Done!
```

**Alternative (bad):**

```javascript
// Get task
// Get board to find board name (extra query)
// Find category in board to get category name
// Result: Multiple queries for every task detail page
```

**Trade-off:**

- Must update cached fields when names change (rare)
- But saves queries on every page load (common)

---

#### Decision 3: Store taskIds array in board categories

**Why:**

- Preserves exact order users arranged
- Easy to reorder (just rearrange array)
- Can rebuild if corrupted (from task.categoryId)

**Alternative (bad):**

```javascript
// Add "position" field to every task:
{
  _id: "task_001",
  categoryId: "todo",
  position: 0
}

// Problems:
// - Reordering one task = update multiple tasks
// - If positions get out of sync, hard to fix
// - Extra field on every task
```

---

#### Decision 4: Use compound index { boardId: 1, categoryId: 1 }

**Why:**

```javascript
// Load just one category (lazy loading):
const tasks = await Task.find({
  boardId: "board_123",
  categoryId: "todo",
});
// Instant with compound index!

// Also works for just boardId:
const tasks = await Task.find({ boardId: "board_123" });
// Still fast! Uses left part of index.
```

**Alternative (bad):**

- No index: Scan all 10,000 tasks every time
- Single index: Can only optimize for one query pattern

---

## Alternative Approaches

### Alternative 1: Embed Everything in Board

**Schema:**

```javascript
{
  _id: "board_123",
  name: "My First Board",
  categories: [
    {
      id: "todo",
      name: "To Do",
      tasks: [                           // ‚Üê Tasks embedded here!
        {
          _id: "task_001",
          name: "Setup project",
          description: "...",
          priority: "high"
          // ... all task fields
        },
        {
          _id: "task_002",
          // ... all task fields
        }
      ]
    }
  ]
}
```

**Problems:**

‚ùå **MongoDB 16MB document limit**

- Each task is ~2KB
- 16MB / 2KB = 8,000 tasks max per board
- What if users need more?

‚ùå **Can't query individual tasks**

```javascript
// Show task T-100:
// Must load ENTIRE board first!
// Then search through all categories
// Then find task
```

‚ùå **Task detail page requires board ID**

```javascript
// URL: /task/T-100
// How do you know which board to load?
// You don't! Need to search ALL boards!
```

‚ùå **Inefficient updates**

```javascript
// Change one task's description:
// Must load entire board
// Modify one task
// Save entire board
// Wasteful!
```

---

### Alternative 2: Separate Category Collection

**Schema:**

```javascript
// Boards collection
{ _id: "board_123", name: "My Board" }

// Categories collection
{
  _id: "cat_001",
  boardId: "board_123",
  name: "To Do",
  taskIds: ["task_001", "task_003"]
}

// Tasks collection
{
  _id: "task_001",
  categoryId: "cat_001",
  name: "Setup project"
}
```

**Why we didn't do this:**

‚ùå **Extra collection = extra complexity**

- More queries needed
- More indexes to maintain
- More things that can go wrong

‚ùå **Categories rarely exist independently**

- Always accessed through their board
- Never need "all categories across all boards"
- So why separate them?

‚ùå **Board page requires 3 queries**

```javascript
const board = await Board.findById("board_123");
const categories = await Category.find({ boardId: "board_123" });
const tasks = await Task.find({ boardId: "board_123" });
// vs our 2 queries (board + tasks)
```

**When this WOULD be good:**

- If categories could belong to multiple boards
- If you need to query categories independently
- If boards have 100+ categories

**Our case:**

- Categories belong to ONE board
- Always accessed through board
- Typically 3-10 categories per board
- **Embedding makes sense!**

---

### Alternative 3: No taskIds Array (Use Timestamps)

**Schema:**

```javascript
// Board - no taskIds
{
  _id: "board_123",
  categories: [
    {
      id: "todo",
      name: "To Do"
      // No taskIds array!
    }
  ]
}

// Task - added position field
{
  _id: "task_001",
  categoryId: "todo",
  position: 0,           // ‚Üê Position in category
  movedAt: Date          // ‚Üê Last moved timestamp
}
```

**Query for ordered tasks:**

```javascript
const tasks = await Task.find({
  boardId: "board_123",
  categoryId: "todo",
}).sort({ position: 1 });
```

**Problems:**

‚ùå **Reordering is complex**

```javascript
// User drags task from position 5 to position 2
// Must update positions: 2‚Üí3, 3‚Üí4, 4‚Üí5, 5‚Üí2
// Multiple task updates!
```

‚ùå **Position conflicts**

```javascript
// Two users drag tasks simultaneously
// Both tasks end up at position: 3
// Need conflict resolution logic
```

‚ùå **Gap handling**

```javascript
// Positions: [0, 1, 5, 6]
// Where's 2, 3, 4?
// Need periodic "reindexing" to clean up
```

**When this WOULD be good:**

- If you need complex sorting (by priority, date, etc.)
- If order changes frequently
- If you want to preserve history of movements

**Our case:**

- Simple drag-and-drop ordering
- Order is user-controlled, not calculated
- **Array is simpler and faster!**

---

## Summary: The Golden Rules

### 1. **Tasks Store Their Location**

```javascript
{
  boardId: "board_123",      // Which board?
  categoryId: "todo"         // Which category?
}
```

‚úÖ Fast board queries
‚úÖ Fast category filtering

### 2. **Tasks Cache Parent Names**

```javascript
{
  boardName: "My Board",     // Cached
  categoryName: "To Do"      // Cached
}
```

‚úÖ Fast task detail pages
‚úÖ No extra queries needed

### 3. **Boards Store Task Order**

```javascript
{
  categories: [
    {
      taskIds: ["task_001", "task_003", "task_004"],
    },
  ];
}
```

‚úÖ Preserves user's order
‚úÖ Easy to reorder

### 4. **Use Indexes Wisely**

```javascript
{ boardId: 1 }                      // For board queries
{ taskId: 1, unique: true }         // For task lookups
{ boardId: 1, categoryId: 1 }       // For category filtering
```

‚úÖ Queries are O(log n) instead of O(n)
‚úÖ Scales to millions of tasks

### 5. **Use Transactions for Multi-Step Changes**

```javascript
// Move task between categories:
// 1. Update task
// 2. Remove from old category
// 3. Add to new category
// All or nothing!
```

‚úÖ Data stays consistent
‚úÖ No partial updates

---

## Next Steps

Now that you understand the schema:

1. **Backend:** Implement the API endpoints in `DATABASE_SCHEMA.md`
2. **Frontend:** Connect Redux to real API (replace JSON files)
3. **Testing:** Test edge cases (concurrent moves, deletions)
4. **Optimization:** Add Redis caching for hot boards
5. **Real-time:** Add WebSocket for live collaboration

---

## Questions to Test Your Understanding

1. **Why do we store `boardId` on every task?**
   <details>
   <summary>Answer</summary>
   So we can fetch all tasks for a board with ONE query instead of hundreds.
   </details>

2. **Why cache `boardName` and `categoryName` on tasks?**
   <details>
   <summary>Answer</summary>
   So task detail pages load with ONE query instead of needing to fetch the board too.
   </details>

3. **What does the `taskIds` array in categories do?**
   <details>
   <summary>Answer</summary>
   Preserves the exact order users arranged tasks in each category.
   </details>

4. **Why use a transaction when moving tasks between categories?**
   <details>
   <summary>Answer</summary>
   To ensure all 3 operations (update task, remove from old, add to new) happen together or not at all. Prevents data corruption.
   </details>

5. **What does the compound index `{ boardId: 1, categoryId: 1 }` optimize?**
   <details>
   <summary>Answer</summary>
   Queries that filter by both board AND category (like loading one column). Also works for queries with just boardId.
   </details>

---

**üéâ Congratulations!** You now understand the complete database schema design!
